#!/usr/bin/perl
use strict;
use warnings;

# This file contains a program that reads the lyrics file generated by music Score Fetch
# and then asks user for input line. Then on the basis of similarity between input sentence
# and songs computed we compute the best song possible, kind of like a rudimentary processor

# A hashmap which stores the frequency of the lyrics the key for the data structure is 
# the song number and the value is 
my @lyrics_frequencies = ();

# Contains both hindi and english stop words
my @stopWords = ("and", "the", "or", "to", "ki", "tu");

# A hashmap of all the stop words in songs
my %stoplist_hash = ();

# This map stores the similarities between songs and query
my %similarity_map = ();

# Takes an input sentence from user of lyrical content to input query
my %input_sentence_hash = ();

# Song number song file name map 
my %song_num_name_hash = ();

# The number of songs in the analysis
my $song_number = 1;

# The number of relevant documents that the user wishes to view
my $num_relevant;

# The default number of relevant documents that a user wishes to view
my $default_num_relevant = 10;

# Construct the stop list hash
foreach my $word (@stopWords)
{
    $stoplist_hash{$word} = 1;
}

# Method to read the lyrics files and compute the lyrics frequency hash map
sub readLyricsFiles {

    # Sorted to maintain ordering consistency
    my @notestream_files = sort glob("*.lyrics");
    
    # Read each file and construct the lyric frequency hash
    foreach my $filename (@notestream_files) {
    
        open(my $fh, $filename) or die "Could not open file '$filename' $!";
        
        while (my $line = <$fh>) {
            chomp $line;
          
            my @lyricsArray = split /\s+/, $line;
          
            # Populate the lyrics frequency hash
            foreach my $word (@lyricsArray)
            {
                if (! exists $stoplist_hash{ $word }) {
                    if (!exists $lyrics_frequencies[$song_number]{$word}) {
                        $lyrics_frequencies[$song_number]{$word} = 1;
                    } else {
                        $lyrics_frequencies[$song_number]{$word} += 1;
                    }
                }      
            }
        }
        
        $song_num_name_hash{$song_number} = $filename;
        
        $song_number += 1;
        
        close ($fh);
    }   
}

# Reads the input sentence and constructs query vector from it
sub readInputSentence {
    print "Please input some text to indicate a lyrical preference: ";
    my $input_line = <STDIN>;
    
    print "Please input the number of songs you wish to view in rank order:";
    $num_relevant = <STDIN>;
    
    # Cant accept negative numbers so take default value
    if ($num_relevant < 0) 
    {
        print "You input a negative number which is not valid, taking default value ", $default_num_relevant, "\n";
        $num_relevant = $default_num_relevant;
    }
    
    my @input_words = split /\s+/, $input_line;
    
    # Construct the stop list hash
    foreach my $word (@input_words)
    {
        $input_sentence_hash{$word} = 1;
    }
}

# Presents the rank order based on number of preferences given by user
sub presentRankOrder {

    # Sort hashmap based on descending order of values 
    my @simOrderSortedKeys = sort { $similarity_map{$b} <=> $similarity_map{$a} } keys(%similarity_map);
    
    # To make the array start from index = 1
    unshift @simOrderSortedKeys, -1;

    # You cant view more relevant documents than the number of crawled songs, so take min
    my $view_relevant = ($song_number - 1, $num_relevant)[$song_number - 1 > $num_relevant];
    
    print "The relevant songs are in files: \n";    
    
    for my $index(1..$view_relevant) {
        print $song_num_name_hash{$simOrderSortedKeys[$index]}, "\n";
    }
}

# Compute similarities of query with 
sub computeSimilarities {

    for my $index (1..$song_number - 1) {
       
        my $sim = &cosine_sim_a($lyrics_frequencies[$index], \%input_sentence_hash);
	   
	    # Store the similarities along with the song name
	    $similarity_map{$index} = $sim;
    }
}

# Gets the cosine similarity between two vectors
sub cosine_sim_a {

    my $vec1 = shift;
    my $vec2 = shift;

    my $num     = 0;
    my $sum_sq1 = 0;
    my $sum_sq2 = 0;

    my @val1 = values %{ $vec1 };
    my @val2 = values %{ $vec2 };
    
    # For debugging vector lengths passed to similarity measures.
    # print scalar (@val1), " " ,scalar (@val2), "\n";

    # determine shortest length vector. This should speed 
    # things up if one vector is considerable longer than
    # the other (i.e. query vector to document vector).

    if ((scalar @val1) > (scalar @val2)) {
	my $tmp  = $vec1;
	   $vec1 = $vec2;
	   $vec2 = $tmp;
    }

    # calculate the cross product

    my $key = undef;
    my $val = undef;

    while (($key, $val) = each %{ $vec1 }) {
	$num += $val * ($$vec2{ $key } || 0);
    }

    # calculate the sum of squares

    my $term = undef;

    foreach $term (@val1) { $sum_sq1 += $term * $term; }
    foreach $term (@val2) { $sum_sq2 += $term * $term; }

    return ( $num / sqrt( $sum_sq1 * $sum_sq2 ));
}

sub main {
    print "WELCOME TO THE LYRICAL ANALYSIS COMPONENT \n";
    &readLyricsFiles;
    &readInputSentence;
    &computeSimilarities;
    &presentRankOrder
}

&main;
